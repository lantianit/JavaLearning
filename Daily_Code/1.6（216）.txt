public class ThreadLocaDemo {

    private static ThreadLocal<String> localVar = new ThreadLocal<String>();

    static void print(String str) {
        //打印当前线程中本地内存中本地变量的值
        System.out.println(str + " :" + localVar.get());
        //清除本地内存中的本地变量
        localVar.remove();
    }
    public static void main(String[] args) throws InterruptedException {

        new Thread(new Runnable() {
            public void run() {
                ThreadLocaDemo.localVar.set("local_A");
                print("A");
                //打印本地变量
                System.out.println("after remove : " + localVar.get());

            }
        },"A").start();

        Thread.sleep(1000);

        new Thread(new Runnable() {
            public void run() {
                ThreadLocaDemo.localVar.set("local_B");
                print("B");
                System.out.println("after remove : " + localVar.get());

            }
        },"B").start();
    }
}

A :local_A
        after remove : null
        B :local_B
        after remove : null
class ObjectCommunicate {
    public static void main(String[] args) throws InterruptedException {
        Object lock = new Object();
        // 创建线程并执行
        new Thread(() -> {
            System.out.println("线程1: 开始执行");
            synchronized (lock) {
                try {
                    System.out.println("线程1: 进入等待");
                    lock.wait();
                    System.out.println("线程1: 继续执行");
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("线程1: 执行完成");
            }
        }).start();
        Thread.sleep(1090);
        synchronized (lock)

        {
            // 唤醒线程
            System.out.println("执行 notifyAl1()");
            lock.notifyAll();
        }
    }
}
class LockSupportCommunicate {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            LockSupport.park();
            System.out.println("线程1");
        },"线程1");
        t1.start();
        Thread t2 = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("唤醒线程1");
            LockSupport.unpark(t1);
        },"线程2");
        t2.start();
    }
}

class MyBlockingQueue {
    private int[] items = new int[1000];
    private int tail = 0;
    private int head = 0;
    private int size = 0;

    public void put(int elem) throws InterruptedException {
        synchronized (this) {
            while (size == items.length) {
                this.wait();
            }
            items[tail++] = elem;
            tail++;
            if (tail >= items.length) {
                tail = 0;
            }
            size++;
            this.notify();
        }
    }
    public int take() throws InterruptedException {
        synchronized (this) {
            while (size == 0) {
                this.wait();
            }
            int ret = items[head++];
            if (head >= items.length) {
                head = 0;
            }
            size--;
            this.notify();
            return ret;
        }
    }
}

import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        quickSort(nums,0,n-1);
        for (int i = 0; i < n; i++) {
            System.out.print(nums[i] + " ");
        }
    }
    
    public static void quickSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i] + " ");
        }
        System.out.println(nums[l+r >> 1]);
        int x = nums[l+r >> 1];
        int i = l-1, j = r+1;
        while (i < j) {
            do i++; while (nums[i] < x);
            do j--; while (nums[j] > x);
            if (i < j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        quickSort(nums,l,j);
        quickSort(nums,j+1,r);
    }
}
class MyTask implements Comparable<MyTask> {
    private Runnable runnable;
    private long timeStamp;
    public MyTask(Runnable runnable,long delay) {
        this.runnable = runnable;
        this.timeStamp = System.currentTimeMillis() + delay;
    }
    public Runnable getRunnable() {
        return runnable;
    }

    public long getTime() {
        return timeStamp;
    }
    @Override
    public int compareTo(MyTask o) {
        return 0;
    }
}

class MyTimer {
    private BlockingQueue<MyTask> queue = new PriorityBlockingQueue<>();

    private Object locker = new Object();

    public MyTimer() {
        Thread thread = new Thread(() -> {
           while (true) {
               try {
                   synchronized (locker) {
                       MyTask myTask = queue.take();
                       long curTime = System.currentTimeMillis();
                       if (curTime >= myTask.getTime()) {
                           myTask.getRunnable().run();
                       } else {
                           queue.put(myTask);
                           locker.wait(myTask.getTime() - curTime);
                       }
                   }
               } catch (InterruptedException e) {
                   throw new RuntimeException(e);
               }
           }
        });
        thread.start();
    }
    public void schedule(Runnable runnable, long after) throws InterruptedException {
        synchronized (locker) {
            MyTask myTask = new MyTask(runnable, after);
            queue.put(myTask);
            locker.notify();
        }
    }
}